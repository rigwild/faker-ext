import 'qrjs2'
import { chrome } from '../config'
import { dataURLtoFile, filetoBase64, generateQRCode, imageToShortVideo, loadingSvg, QRCodeGenerator } from '../utils'

let selectionObj: Selection = null
let selectionEle: Element = null

// Should we watch for new file inputs?
let monitorFileInputs = false
// Are we currently uploading a file? (to prevent multiple uploads)
let isUploadingFileLock = false

const QRCode = (window as any).QRCode as QRCodeGenerator

function sendMessage(message: any): Promise<any> {
  return new Promise(resolve => chrome.runtime.sendMessage(message, {}, (response: any) => resolve(response)))
}

/**
 * Replace the selected text with the given text
 *
 * Supports custom editable elements (like paragraphs) and input/textarea elements
 *
 * This includes multiple crappy hacks or deprecated stuff
 * @param str New text to replace the selected text with
 */
function replaceSelectionWithStr(str: string) {
  // See https://stackoverflow.com/a/59582075
  // This is deprecated but still works in chrome 98
  document.execCommand('insertText', false, str)
  return

  // Check if the element is an input/textarea
  // (the Selection API doesn't work on inputs/textareas)
  // See https://stackoverflow.com/a/20427804
  if ((selectionEle as any).value !== undefined) {
    const ele = selectionEle as HTMLInputElement
    ele.value = ele.value.slice(0, ele.selectionStart) + str + ele.value.slice(ele.selectionEnd)
  }
  // Element is not an input/textarea, but is editable using the Selection API
  else {
    // This shit is deprecated but the browsers have not yet settled on a proper replacement yet
    // If it stops to work, try this (will not work with every editable elements)
    // A hack to paste some text into an editable element
    // See https://stackoverflow.com/a/63643176
    // let dataTransfer = new DataTransfer()
    // dataTransfer.setData('text/plain', str)
    // selectionEle.dispatchEvent(
    //   new ClipboardEvent('paste', {
    //     clipboardData: dataTransfer,
    //     bubbles: true,
    //     cancelable: true
    //   })
    // )
    // dataTransfer.clearData()
    //
    //
    // Old trick, does not work if the website uses a js framework like React
    // const newNode = document.createTextNode(str)
    // // Remove currently selected text
    // selectionObj.deleteFromDocument()
    // // Insert new text
    // const range = selectionObj.getRangeAt(0)
    // range.insertNode(newNode)
    // // Move the cursor to the end of the inserted text
    // selectionObj.collapse(newNode, 1)
  }
}

/**
 * Hook a file input element to upload the selected file to the self-hosted server
 * before it is submitted then send a QR code image pointing to the uploaded file URI
 * to the input element instead
 * @param e Event
 */
async function fileInputHookHandler(e: Event): Promise<void> {
  if (isUploadingFileLock) {
    console.log('[Faker] Uploading file is locked')
    return
  }
  if (!monitorFileInputs) {
    console.log('[Faker] File input hook disabled')
    return
  }

  const ele = e.target as HTMLInputElement

  // Prevent subsequent change event listeners from being triggered
  e.stopImmediatePropagation()
  console.log('[Faker] Intercepting a file upload')

  const file = ele.files[0]
  if (!file) return

  // Check the uploaded file is an image or a video
  if (!['image', 'video'].some(type => file.type.startsWith(type))) {
    const log = `[Faker] File type ${file.type} is not supported! Only images and videos are supported.`
    console.log(log)
    alert(log)
    return
  }

  // Upload the media (image or video) to the self-hosted server and get its URI
  isUploadingFileLock = true
  showLoadingOverlay('Faker is uploading your file...')

  const fullExternalUri: string = await sendMessage({
    action: 'ASK_UPLOAD_FILE',
    file: {
      base64: await filetoBase64(file), // File is not auto-serializable
      name: file.name,
      type: file.type,
      size: file.size
    },
    websiteUrl: new URL(location.href)
  })
  console.log(`[Faker] External link generated by the server for media: ${fullExternalUri}`)

  showLoadingOverlay('Faker is generating a QR code...')
  const qrCodeDataUrl = generateQRCode(QRCode, fullExternalUri)

  let injectedFile: File
  if (file.type.startsWith('image')) {
    const qrCodeFile = dataURLtoFile(qrCodeDataUrl, 'qr.png')
    injectedFile = qrCodeFile
  } else if (file.type.startsWith('video')) {
    // Render the QR code as a small video
    console.log(`[Faker] Rendering the QR code image as a short video`)
    showLoadingOverlay('Faker is rendering a QR code video...')
    const qrCodeBlob = await imageToShortVideo(qrCodeDataUrl)
    injectedFile = new File([qrCodeBlob], 'qr.webm', { type: 'video/webm' })
  }

  // Replacing the file with `ele.files[0]` directly is not possible as FileList is read-only
  const newFilesKey = new DataTransfer()
  newFilesKey.items.add(injectedFile)
  ele.files = newFilesKey.files
  console.log(`[Faker] Injected the replaced media into the file input`, injectedFile)

  isUploadingFileLock = false
  hideLoadingOverlay()

  ele.dispatchEvent(e)
}

function showListeningForUploadOverlay() {
  console.log('[Faker] Show the listening for upload overlay')

  const overlayId = 'faker-listening-for-upload-overlay'
  let overlay = document.getElementById(overlayId)

  // Overlay is already in the page but hidden
  if (overlay) {
    const container = overlay.querySelector<HTMLDivElement>('#faker-listening-for-upload-overlay-container')
    container.style.opacity = '0.95'
    container.style.zIndex = '9999999'
    return
  }

  overlay = document.createElement('div')
  overlay.id = 'faker-listening-for-upload-overlay'
  overlay.style.display = 'flex'
  overlay.style.alignItems = 'center'
  overlay.style.justifyContent = 'center'

  overlay.innerHTML = `
    <div id="faker-listening-for-upload-overlay-container" style="
        z-index: 99999999;
        position: fixed;
        display: flex;
        align-items: center;
        justify-content: center;
        bottom: 40px;
        color: white;
        font-family: Arial, sans-serif;
        font-size: 16px;
        background-color: #4158D0;
        background-image: linear-gradient(43deg, #4158D0 0%, #C850C0 46%, #FFCC70 100%);
        padding: 5px 10px 5px 0px;
        border-radius: 50px;
        box-shadow: rgb(0 0 0 / 35%) 0px 5px 15px;
        transition: opacity 0.5s ease-in-out;
        opacity: 0;
      "
    >
      ${loadingSvg}
      <span>Faker is listening for file uploads... </span>
      <button id="faker-listening-for-upload-overlay-stop-button" style=" 
          font-family: Arial, sans-serif;
          font-size: 12px;
          padding: 7px 10px;
          margin-left: 20px;
          border-radius: 50px;
          border: none;
          box-shadow: rgb(0 0 0 / 35%) 0px 2px 5px;
          cursor: pointer;
          background: #ffffff;
        "
      >
        Stop
      </button>
    </div>
  `.replace(/\n/g, '')

  const svg = overlay.querySelector('svg')
  svg.style.width = '40px'
  svg.style.height = '40px'
  svg.style.margin = '0 10px'

  const container = overlay.querySelector<HTMLDivElement>('#faker-listening-for-upload-overlay-container')
  container.style.opacity = '0'
  container.style.zIndex = '9999999'

  document.body.appendChild(overlay)

  // Show on next frame to let the browser render the DOM and execute the transition
  setTimeout(() => {
    container.style.opacity = '0.95'
  }, 1)

  overlay.querySelector('button').addEventListener('click', e => {
    monitorFileInputs = false
    console.log('[Faker] Stopped the file uploads listener')
    container.style.opacity = '0'
    // Put in the background in 500ms so the opacity transition can be completed
    setTimeout(() => {
      container.style.zIndex = '-9999999'
    }, 500)
  })
}

function showLoadingOverlay(message = 'Faker is loading...') {
  console.log('[Faker] Show the loading overlay')

  const overlayId = 'faker-loading-overlay'
  let overlay = document.getElementById(overlayId)

  // Overlay is already in the page but hidden
  if (overlay) {
    overlay.querySelector<HTMLSpanElement>('#faker-loading-overlay-message').innerText = message
    const container = overlay.querySelector<HTMLDivElement>('#faker-loading-overlay-container')
    container.style.opacity = '0.8'
    container.style.zIndex = '9999999'
    return
  }

  overlay = document.createElement('div')
  overlay.id = overlayId

  overlay.innerHTML = `
    <div id="faker-loading-overlay-container" style="
        z-index: -9999999;
        position: fixed;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        width: 100%;
        top: 0;
        left: 0;
        color: white;
        font-family: Arial, sans-serif;
        font-size: 20px;
        background-color: #4158D0;
        background-image: linear-gradient(43deg, #4158D0 0%, #C850C0 46%, #FFCC70 100%);
        transition: opacity 0.5s ease-in-out;
        opacity: 0;
      "
    >
      ${loadingSvg}
      <span id="faker-loading-overlay-message">${message}</span>
    </div>
  `.replace(/\n/g, '')

  const svg = overlay.querySelector('svg')
  svg.style.width = '80px'
  svg.style.height = '80px'
  svg.style.margin = '10px'

  const container = overlay.querySelector<HTMLDivElement>('#faker-loading-overlay-container')
  container.style.opacity = '0'
  container.style.zIndex = '9999999'

  document.body.appendChild(overlay)

  // Show on next frame to let the browser render the DOM and execute the transition
  setTimeout(() => {
    container.style.opacity = '0.8'
  }, 1)
}

function hideLoadingOverlay() {
  const container = document.getElementById('faker-loading-overlay-container')
  if (container) {
    console.log('[Faker] Hide the loading overlay')
    container.style.opacity = '0'
    // Put in the background in 500ms so the opacity transition can be completed
    setTimeout(() => {
      container.style.zIndex = '-9999999'
    }, 500)
  }
}

// We periodically check for new file input elements as some websites like LinkedIn
// create the input element dynamically
// We don't care about adding multiple listeners to the same element as when the same
// listener (function) is already applied to an element, it will not be added by the browser
setInterval(() => {
  if (monitorFileInputs && !isUploadingFileLock) {
    // console.log(document.querySelectorAll('input[type="file"]'))
    document.querySelectorAll('input[type="file"]').forEach((ele: HTMLInputElement) => {
      ele.addEventListener('change', fileInputHookHandler, {
        capture: true,
        once: true
      })
    })
  }
}, 500)

chrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {
  console.log('[Faker] Message from the background script:', message)
  if (message?.action === 'UPLOAD_TEXT_POST_START') {
    showLoadingOverlay('Faker is uploading the text post...')

    selectionObj = window.getSelection()
    selectionEle = document.activeElement
    sendResponse()
  } else if (message?.action === 'UPLOAD_TEXT_POST_END') {
    hideLoadingOverlay()

    // Replace selected text with URI
    replaceSelectionWithStr(message.fullExternalUri)
    sendResponse()
  } else if (message?.action === 'LISTEN_FOR_FILE_UPLOAD') {
    if (!monitorFileInputs) {
      monitorFileInputs = true
      console.log('[Faker] Listening for file uploads')
      showListeningForUploadOverlay()
    }
    sendResponse()
  } else {
    sendResponse({ error: 'Unknown action' })
  }
})
